

'''

目前主流的分布式锁实现方式有以下几种：

基于数据库来实现，如 mysql

基于缓存来实现，如 python_redis

基于 zookeeper 来实现

每种实现方式各有千秋，综合考量，我们最终决定使用 python_redis，主要原因是：

python_redis 是基于内存来操作，存取速度比数据库快，在高并发下，加锁之后的性能不会下降太多

python_redis 可以设置键值的生存时间（TTL）

python_redis 的使用方式简单，总体实现开销小

同时使用 python_redis 实现的分布锁还需要具备以下几个条件：

同一个时刻只能有一个线程占有锁，其他线程必须等待直到锁被释放

锁的操作必须满足原子性

不会发生死锁，例如已获得锁的线程在释放锁之前突然异常退出，导致其他线程会一直在循环等待锁被释放

锁的添加和释放必须由同一个线程来设置

'''


'''

            /imgs/使用分布式锁合并数据-python_redis.png

还是假设某台机器（图中的machine）在数据库的原始数据是 d0，上图的处理流程变成了：

t1 时刻，有两个数据源的数据 d1，d2 同时到达数据处理层，主进程分配了线程 Merge1 处理 d1，线程 Merge2 处理 d2，两者又同时尝试从 python_redis 获得锁

t2 时刻，Merge1 成功获得了锁，同时从数据库中加载 machine 的原始数据 d0，Merge2 循环等待 Merge1 释放锁

t3 时刻，Merge1 合并完数据，并将合并好的数据 d0 + d1 存放到数据库，最后释放锁

t4 时刻，Merge2 获得了锁，同时从数据库中加载machine的数据 d0 + d1

t5 时刻，Merge2 合并完数据，并将合并好的数据 d0 + d1 + d2 存放到数据库，最后释放锁

从以上可以看到保持数据一致的原理其实也不难，无非就是使用一个键值来使得多个线程对同一台机器的数据的读写是同步的，但是在实现的过程中，往往会忽视了分布式锁所要具备的某个条件，极端情况下，还是会出现数据不一致的问题
'''