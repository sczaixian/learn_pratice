


# 调用gc.collect()


'''

python 采用的是引用计数机制为主，标记 - 清除和分代收集两种机制为辅的策略。

引用计数
『引用计数法』的原理是：每个对象维护一个ob_ref字段，用来记录该对象当前被引用的次数，
每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，
一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。

引用计数法有很明显的优点：

高效
运行期没有停顿 可以类比一下Ruby的垃圾回收机制，也就是 实时性：
一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。
实时性还带来一个好处：处理回收内存的时间分摊到了平时。
对象有确定的生命周期
易于实现

原始的引用计数法也有明显的缺点：

维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。
无法解决循环引用的问题。A和B相互引用而再没有外部引用A与B中的任何一个，它们的引用计数都为1，但显然应该被回收


『标记清除（Mark—Sweep）』它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，
第二阶段是把那些没有标记的对象『非活动对象』进行回收。

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，
而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，
可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象
标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些容器对象，
比如 list、dict、tuple，instance 等，
因为对于字符串、数值对象是不可能造成循环引用问题。
Python 使用一个双向链表将这些容器对象组织起来。
不过，这种简单粗暴的标记清除算法也有明显的缺点：
清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象


分代回收总结:

  分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，
每个集合称为一个代，Python将内存分为了3“代”，
分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，
它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，
年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，
而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，
甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。
分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象.

'''